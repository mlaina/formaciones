Hola a todos. Mi nombre es Patrick Schroeder y bienvenido a mi curso Introducción a Sequelize ORM para Node. js. Soy un desarrollador y emprendedor de JavaScript. Me encanta aprender sobre nuevas tecnologías, crear aplicaciones interesantes y compartir mi conocimiento. En este curso, aprenderá a usar Sequelize ORM en un Node. Proyecto js. Sequelize es una herramienta increíble porque facilita la interacción con las bases de datos SQL más populares, como Postgres, MySQL y SQLite. La primera parte de este curso cubrirá los fundamentos de Sequelize. Esto incluye crear un nuevo proyecto, agregar modelos, crear asociaciones de modelos y realizar operaciones CRUD. En el módulo final, lo juntaremos todo y crearemos una aplicación JavaScript de pila completa usando Angular en el front-end. Al final de este curso, sabrá cómo incorporar bases de datos SQL usando Sequelize en cualquier Node. js aplicación. Este curso se hizo pensando en los principiantes, por lo que incluso si tiene poca experiencia con SQL o Node. js, aún podrás seguir y aprender mucho. Espero que se una a mí en este viaje para aprender a construir Node. js usando Sequelize aquí, en Pluralsight.

Características de Sequelize
Intruducción y resumen general
Sequelize facilita la conexión a las bases de datos SQL más populares utilizando objetos JavaScript simples. Mi nombre es Patrick Schroeder y bienvenido a mi curso, Introducción a Sequelize ORM para Node. js. Este curso se dividirá en dos secciones y seis módulos. Los primeros cinco módulos estarán dedicados a familiarizarlo con todas las características principales de Sequelize. Esto incluye la construcción de un nuevo proyecto, la configuración de modelos y la creación de asociaciones. En esta sección, usaremos la ventana de nuestro navegador para ver las respuestas en JSON, junto con un visor de base de datos SQLite para buscar entradas en nuestra base de datos. En el módulo final, juntaremos todo y crearemos el backend para una aplicación Angular existente. En esta aplicación, podrá ver libros y usuarios. Podemos hacer clic en este enlace Editar, que nos llevará a una página de usuario. A partir de ahí, podremos agregar libros a la lista de lectura de un usuario, además de poder guardar un libro favorito para ese usuario. Ahora, antes de sumergirnos por completo, analicemos qué tecnologías usaremos y lo que ya debería saber antes de tomar este curso.

Prerrequisitos
Este curso se hizo pensando en el principiante, pero hay algunos requisitos previos para este curso. Ya debería estar familiarizado con los conceptos básicos de JavaScript, incluidas matrices, variables y objetos. Ya debería tener Node. js instalado en su máquina. Usaré la versión 8. 11. 1 en una máquina con Windows 10. También usaré Visual Studio Code como mi editor de texto preferido, pero usted es libre de usar el editor que desee. También hay algunos elementos "útiles para conocer" para este curso. Será útil si ya tiene alguna experiencia previa trabajando con una base de datos SQL. Sin embargo, cubriré los conceptos básicos de SQL en este módulo para aquellos de ustedes que no tengan conocimiento o experiencia previa. También será útil si ha trabajado con Angular en el pasado, ya que esto es en lo que se basará nuestra interfaz para el proyecto final. Pero, de nuevo, no es completamente necesario ya que les proporcionaré la base de código de frontend completa y cubriré principalmente la construcción de nuestra API.

¿Qué es Sequelize?
Entonces, ¿qué es Sequelize? Sequelize es un asignador relacional de objetos basado en promesas que facilita la interacción con bases de datos SQL dentro de un nodo. Proyecto js. Cuando decimos 'Object Relational Mapper', esto solo significa que podemos definir un modelo de objetos JavaScript que Sequelize transforma en una tabla SQL correspondiente con columnas y filas. Esto nos ahorra la molestia de tener que escribir consultas SQL complejas necesarias para interactuar con nuestra base de datos. Sequelize es un proyecto de código abierto popular disponible para descargar aquí en GitHub. Sequelize también está disponible a través de npm, lo que nos facilita agregarlo a cualquier Node. Proyecto js. A lo largo de este curso, haré referencia a la documentación de la API que se encuentra aquí en docs. sequelizejs. com. Estos documentos proporcionan excelentes ejemplos para muchos de los métodos auxiliares que usaremos al conectarnos a una base de datos, construir modelos y acceder a nuestras tablas de base de datos.

Explicación de la base de datos SQL
Sequelize nos conecta con las bases de datos SQL más populares como MySQL, Postgres y SQLite. Si nunca ha trabajado con bases de datos SQL o tiene conocimientos limitados sobre ellas, este clip le proporcionará una descripción básica. Las bases de datos SQL se utilizan prácticamente en todas partes. Son extremadamente frecuentes en la web. Se las conoce comúnmente como bases de datos relacionales que almacenan datos en tablas. Estas tablas contienen columnas y filas. A cada columna se le asigna un nombre y un tipo de datos. El tipo de datos define qué tipo de valor puede contener la columna, como entero, cadena y fecha. Cada entrada en una tabla está contenida dentro de una fila. A cada fila se le asigna un identificador único conocido como clave primaria. Cuando se usa Sequelize, esta clave primaria se genera automáticamente y se inserta en la columna con el nombre de ID. Se pueden asociar tablas SQL. Entonces, por ejemplo, podemos tener una tabla de Usuarios y una tabla de Publicaciones asociada para que por cada publicación que se agregue, podamos guardar la ID del usuario en su propia columna. Luego, cuando recuperamos esa publicación, también podemos recuperar todos los datos del usuario asociado. La respuesta de esta asociación en JSON se vería así. Esto se llama unión. Las uniones son una característica muy poderosa de las bases de datos SQL y se tratarán en profundidad en nuestro módulo sobre asociaciones. Entonces, para revisar: las bases de datos SQL contienen tablas. Estas tablas contienen columnas y filas. Cada nueva entrada en una tabla se agrega como una fila y tiene un identificador único conocido como clave principal. Cuando usamos una base de datos SQL, podemos unir dos tablas diferentes para enviar datos de ambas tablas haciendo referencia a una clave primaria.

Secuela utiliza promesas
Sequelize se basa en promesas de forma predeterminada. Una promesa en JavaScript representa la eventual finalización (o falla) de una operación asincrónica y su valor resultante. Debido a que JavaScript es de un solo subproceso, si solo hiciéramos una solicitud a nuestra base de datos sin una promesa o devolución de llamada, nuestro navegador estaría bloqueado hasta que se devolviera alguna respuesta. Sequelize utiliza internamente la biblioteca de promesas llamada Bluebird. Esto significa que podemos utilizar cualquiera de los métodos que se encuentran en este sitio web bluebird al realizar solicitudes a nuestra base de datos. Las dos funciones principales que usaremos a lo largo de este curso son entonces y captura. La función then se encadena después de que se realiza una solicitud y, si la solicitud es exitosa, contendrá un objeto con el conjunto de datos resultante. La función catch está encadenada después de la función then y contiene un objeto de error en caso de que haya ocurrido un error. Y aquí hay un código de ejemplo. Entonces, primero, encontramos al usuario usando un método de solicitud de findById. La función then está encadenada a la solicitud y contiene en su argumento los datos de respuesta sobre el éxito. Se llamará al método catch en caso de que haya un error y contendrá un objeto de respuesta al que podemos acceder a través de su argumento. Ahora, si ya está familiarizado con Node. js, es posible que conozca la sintaxis async / await más nueva que simplifica esta estructura de promesa. En aras de la coherencia en este curso, utilizaré la estructura de promesa que se muestra en esta diapositiva. Sin embargo, si lo desea, puede refactorizar fácilmente todo el código usando async y await, lo que haría que la diapositiva anterior se vea así.

Beneficios de Sequelize
Ahora que está al tanto de lo que es Sequelize, repasemos los principales beneficios de usar Sequelize en su Node. js proyectos. El primer gran beneficio de usar Sequelize es que nos proporciona muchos métodos útiles que nos ahorran la molestia de escribir mucho código repetitivo. Todos los motores de bases de datos SQL populares como MySQL y Postgres ya tienen sus propias bibliotecas npm que podríamos usar en nuestro Node. Proyecto js. Pero al optar por usar Sequelize como intermediario, podemos realizar los mismos tipos de funciones con mucho menos código. Otro gran beneficio de usar Sequelize es que todo el código que escribimos es JavaScript. Esto nos ahorra tener que escribir consultas SQL bastante complejas. Sequelize nos proporciona una API muy robusta que podemos usar para construir modelos y consultar o mutar datos. Cuando usamos Sequelize, obtenemos seguridad incorporada bajo el capó, como el escape automático de reemplazos para prevenir ataques de inyección SQL. Sequelize no va a ninguna parte. Ha existido durante muchos años, se mantiene activamente y tiene una gran comunidad de entusiastas en Stack Overflow para ayudar a responder cualquier pregunta. Incluso hay una herramienta CLI que puede descargar para ayudar con la configuración del proyecto y con las migraciones de la base de datos.

Resumen
En este módulo, cubrimos los fundamentos de lo que es Sequelize junto con los beneficios que ofrece. Esto incluyó una revisión de las bases de datos SQL. Y también una introducción a las promesas, que Sequelize utiliza cuando recibe una respuesta de nuestra base de datos. En el siguiente módulo, configuraremos un nuevo proyecto, crearemos nuestro primer modelo y sincronizaremos ese modelo con una base de datos.

Configuración de secuenciación
Introducción
Sequelize facilita la interacción con bases de datos SQL cuando se trabaja con Node. js. Mi nombre es Patrick Schroeder y bienvenido de nuevo a Introducción a Sequelize ORM para Node. js. En este módulo, veremos cómo configurar un nuevo proyecto Sequelize utilizando la base de datos SQLite. Una vez que nuestro proyecto esté configurado, comenzaremos a trabajar en nuestro modelo de usuario. Los modelos están en el corazón de Sequelize y definen los pares clave-valor que crean nuestras tablas y columnas. Una vez que nuestro modelo esté en su lugar, sincronizaremos nuestro modelo con nuestra base de datos, crearemos algunos datos y luego veremos los resultados. Terminaremos este módulo discutiendo qué tipos de datos se pueden enviar a nuestra base de datos y cómo las claves primarias son identificadores únicos generados automáticamente que se utilizan para realizar un seguimiento de las filas de nuestra tabla.

Instalación de SQLite
Al construir un nuevo proyecto de Sequelize, primero debemos decidir qué base de datos queremos usar. Sequelize nos da la opción de utilizar cuatro de las bases de datos SQL más populares. Estos cuatro son MySQL, Postgres, SQLite y MSSQL. Dado que desarrollaremos nuestro proyecto localmente, la base de datos que usamos debe estar instalada en nuestra máquina. Para que se familiarice con Sequelize, he decidido utilizar la base de datos SQLite. SQLite es una excelente opción para construir nuestros ejemplos porque es una base de datos simple y liviana a la que se puede acceder a través de la línea de comandos. Ya puede encontrar SQLite preinstalado en muchos sistemas operativos Apple OS X. Como estoy en una máquina con Windows 10, lo guiaré a través del proceso de descarga desde mi computadora. Este proceso es muy similar a Windows 8, y si está en una Mac, SQLite ya está preinstalado o podrá descargarlo muy fácilmente siguiendo uno de los enlaces de descarga aquí en sqlite. org / download. html. Voy a descargar el archivo zip bajo los binarios precompilados para Windows, que incluye un shell de línea de comandos y es la tercera opción hacia abajo. Una vez descargado, haré clic derecho en la descarga y extraeré los archivos. Voy a ir a esta carpeta para encontrar una carpeta de herramientas, que contiene nuestros archivos ejecutables, y cambiarle el nombre a sqlite3, y luego mover esta carpeta a mi directorio raíz C usando cortar y pegar. Ahora también quiero editar mis variables de entorno para incluir la ruta a esta carpeta. La razón por la que estoy haciendo esto es que quiero poder ejecutar el comando sqlite3 desde mi terminal, y abrirá la base de datos SQLite. Entonces, para hacer eso, iré a mi carpeta sqlite3, copiaré la ubicación de mi carpeta aquí mismo y luego navegaré hasta donde se encuentran mis variables de entorno, que está debajo de mi Panel de control, Sistema, Seguridad, luego Sistema avanzado settings es donde puedo encontrar mi enlace de variables de entorno. Luego resaltaré la ruta aquí y haré clic en Editar, luego haré clic en Nuevo y pegaré la ruta de la carpeta SQLite. Haga clic en Aceptar para salir. Y ahora quiero probar la creación de una nueva base de datos. Puedo hacer esto abriendo cualquier consola de terminal. Y en este caso, solo abriré mi ventana de consola Cmder para Windows. Y puedo escribir el comando sqlite3, que primero proporcionará información sobre la versión que estoy usando, y me permite saber que estoy conectado a una base de datos transitoria en memoria. Y esto solo significa que cualquier base de datos abierta se cerrará cuando se cierre nuestra conexión con sqlite3. Hay una serie de comandos disponibles a los que podemos acceder escribiendo. ayuda. Podemos usar cualquiera de estos comandos aquí para crear y manipular una base de datos SQLite. Así que probemos esto creando una nueva base de datos dentro de nuestra carpeta sqlite3. Primero saldré de SQLite escribiendo. dejar. Luego me moveré a la ubicación de mi carpeta sqlite3, que se encuentra en la raíz de mi unidad C. Y luego puedo usar el comando sqlite3 más el nombre que quiero para mi nueva base de datos, que será testDB. db. Ahora se ha creado una nueva base de datos dentro de mi carpeta sqlite3, pero si navego a la carpeta, puede ver que no hay nada allí. Entonces, la base de datos está realmente oculta antes de que se use o acceda a ella. Entonces, para acceder a la base de datos y revelar su presencia, puedo volver a mi terminal y ejecutar el comando. bases de datos. Esto enumerará todas las bases de datos SQLite y revelará nuestro archivo testDB recién creado.

Configuración del proyecto
Con SQLite ahora configurado en nuestra máquina, empecemos a trabajar en la construcción de un nuevo proyecto de nodo. Usaré Visual Studio Code en una máquina con Windows. También usaré Cmder dentro de Visual Studio como mi ventana de terminal preferida. Puede encontrar más información sobre esta herramienta que estoy usando cmder. red. Algunas ventajas que ofrece es Git integrado y una mejor interfaz visual. Trabajando ahora desde mi terminal, grabaré un cd en mi escritorio. A partir de ahí, crearé una nueva carpeta usando el comando md, y el nombre de esta carpeta, que es pseq, luego ingresaré en esta nueva carpeta. Crearé un nuevo archivo ahora escribiendo touch y luego server. js, que será el punto de entrada a mi proyecto Node. Puedo crear un paquete nuevo. json usando el comando npm init, y luego use la marca --y para rellenar previamente el paquete. json con información básica que puede ver aquí. El siguiente paso es instalar los paquetes que usaremos. Usaré Express aquí para poder crear fácilmente un servidor y algunas rutas. Puedo hacerlo escribiendo npm i express. Instalaremos Sequelize y luego también necesitamos incluir la base de datos. Cada base de datos tiene su propio paquete que debe incluirse. Como estamos usando SQLite, existe un paquete llamado sqlite3. Luego usaré el indicador --S para guardar estas bibliotecas en nuestro paquete. json archivo. Una nota rápida aquí sobre la descarga de sqlite3, puede encontrar más información sobre este paquete en npmjs. sitio web com. Este paquete puede usarse por sí mismo para crear y administrar una base de datos SQL en Node, o podemos usar este paquete junto con Sequelize para evitar tener que escribir estas declaraciones SQL. Ahora, volviendo a mi editor, agregaré la carpeta de mi proyecto en Visual Studio Code. Y ahora voy a abrir mi servidor. js e inclúyalo primero en Express y luego en Sequelize. Agregaré una referencia de variable a Express para que podamos crear su servidor y rutas junto con la referencia a un número de puerto en el que quiero ejecutar mi proyecto, que será 8001. Observe aquí que también hemos descargado sqlite3 de npm, pero no necesitamos hacer referencia al paquete en nuestro archivo de servidor ya que Sequelize se encargará de esta importación automáticamente. En la parte inferior de este archivo, incluiré ahora el código para crear un nuevo servidor Express y también imprimiré un mensaje en la consola cuando se conecte correctamente. Mi función de guardado automático está activada aquí en mi código de Visual Studio, por lo que mis archivos se guardarán automáticamente. Luego abriré mi terminal usando Ctrl + `y probaré este código escribiendo npm start. Y aquí podemos ver el mensaje de que nuestro servidor se está ejecutando en el puerto 8001.

Conectando a la base de datos
Y ahora estamos listos para conectar Sequelize a nuestra base de datos. Puedo hacer esto creando primero una referencia de variable llamada conexión, que almacenará una instancia de Sequelize. La instancia de Sequelize es una función constructora, por lo tanto, la nueva palabra clave, y una vez que agrego estos paréntesis, nuestro IntelliSense nos dice exactamente lo que espera nuestra instancia de Sequelize. Primero espera el nombre de nuestra base de datos, que es una cadena, y luego un nombre de usuario y luego una contraseña, que también son cadenas. Ahora, estos tres argumentos son necesarios, pero como nos estamos conectando a una base de datos SQLite local, estos tres argumentos pueden ser cualquier fragmento de texto que desee. Entonces, en nuestro caso, solo ingresaré db, user y pass. El cuarto parámetro es un objeto opcional que usamos para asignar ciertos valores de la base de datos. Cerraré el Explorer aquí ahora para darnos más espacio. Y dentro de nuestro objeto, primero tendremos que asignar un nombre de host, que será localhost, el dialecto, que le dice a Sequelize qué base de datos SQL estamos usando, y en nuestro caso, es SQLite, y como estamos usando SQLite, también necesitamos incluir una clave de almacenamiento, que es la ruta hacia donde queremos que exista nuestro archivo de base de datos. Va a existir en nuestro directorio raíz dentro de la carpeta pseq. Y este nombre de archivo puede ser el que desee siempre que su extensión sea sqlite. Y, por último, necesito agregar un operatorAliases establecido en falso. Esto evitará que recibamos ciertas advertencias de obsolescencia dentro de nuestra consola. Con nuestra instancia de Sequelize completamente configurada, ahora podemos probarla. Para hacer esto, puedo usar la referencia de conexión. autenticar, para forzar la apertura de nuestra base de datos. Y luego pasaré mensajes de registro después de una conexión exitosa, junto con un mensaje de error de captura en caso de que nuestro intento de conexión falle. Volveré a abrir la ventana de mi terminal y cerraré el servidor usando Ctrl + C, luego lo reiniciaré escribiendo npm start. Y puede ver aquí que recibimos un mensaje que indica una conexión exitosa. Y también puede ver que obtenemos un db. sqlite creado y agregado a nuestro proyecto. Ahora ha configurado un nuevo Node. js se conectó a un servidor y creó una nueva instancia de base de datos Sequelize que usa SQLite. ¡Gran trabajo! El siguiente paso será empezar a utilizar nuestra base de datos.

Modelos
El poder de Sequelize radica en su capacidad para mapear objetos JavaScript en tablas SQL. Para lograr este vínculo entre objetos y tablas, definimos modelos. Estos modelos luego se asignan o transforman en tablas y columnas dentro de una base de datos SQL. Entonces, por ejemplo, podemos definir un modelo con el nombre de Usuario, luego agregar a ese modelo pares clave-valor de nombre y biografía. Estos son los que se conocen como atributos. El nombre de la clave se asignará a una columna SQL y el valor será el tipo de datos que se permite dentro de la columna. El nombre del modelo de Usuario se asignará a una tabla SQL y se pluralizará automáticamente, por lo que Usuario se convertirá en una tabla de Usuarios. Y la tabla contendrá columnas llamadas nombre y biografía. Cualquier dato almacenado aquí coincidirá con el tipo de datos definido en el modelo. Ahora voy a guiarte a través de la creación de un nuevo modelo en la siguiente diapositiva, y luego crearemos el modelo dentro de nuestro proyecto. Al crear un nuevo modelo en Sequelize, primero necesitamos definir una variable que contendrá nuestra referencia de modelo. La convención de nomenclatura típica aquí es capitalizar el nombre del modelo y hacerlo singular. Establecemos esta referencia de conexión igual o Sequelize y luego usamos el método define. El método define crea nuestra instancia de modelo y acepta dos argumentos. El primer argumento es una cadena, que es el nombre de nuestro modelo, y debe coincidir con nuestro nombre de referencia de variable. El segundo argumento es un objeto. Este objeto contendrá todos los atributos que se asignan a nuestra base de datos SQL. De vuelta en mi código de Visual Studio, ahora creemos nuestro modelo de usuario. Comenzaré declarando una referencia para mi modelo como Usuario, luego estableceré esto igual a mi conexión Sequelize. definir. El método define acepta dos argumentos. El primero es el nombre que quiero darle a mi modelo, que será Usuario, y luego crearé un objeto y enumeraré dos atributos que corresponderán a mis columnas SQL. El primer atributo se llamará name y tendrá un tipo de datos de STRING. El segundo atributo se llamará bio con un tipo de datos de TEXTO. Con nuestro modelo en su lugar, ahora solo tenemos que sincronizar el modelo con la base de datos.

Sincronizar base de datos
Para que nuestros modelos se conviertan en tablas dentro de una base de datos SQL, necesitamos llamar al método de sincronización. Podemos llamar a la sincronización en el propio modelo o, más comúnmente, llamar a la sincronización en nuestra conexión Sequelize. Al invocar la sincronización, también podemos pasarle un objeto opcional. Este objeto puede contener algunas propiedades útiles, como el registro. Cuando el registro está configurado en consola. log, podremos ver en nuestra consola el código SQL sin formato que se está utilizando para crear nuestra tabla y columnas. Para comprender mejor cómo usar el método de sincronización y algunas de las opciones disponibles, echemos un vistazo a los documentos de Sequelize. Podemos encontrar la documentación aquí en docs. sequelizejs. com. Al buscar estos documentos para la sincronización de palabras clave, obtenemos algunos resultados. Hagamos clic en el primero en Sincronización de la base de datos. Aquí puede ver algunos ejemplos de cuándo se llama a la sincronización directamente en el modelo, y aquí hay un ejemplo de cuándo la sincronización acepta una propiedad opcional de force establecida en verdadero. Esto eliminará la tabla primero y luego la volverá a crear. Podemos encontrar las otras propiedades opcionales buscando de nuevo sincronizar, y esta vez haciendo clic en Métodos públicos. Y aquí podemos encontrar todas las otras opciones disponibles para nosotros. Usaremos las propiedades de registro y fuerza en nuestros ejemplos. Ahora agreguemos el método de sincronización a nuestro proyecto y revisemos la respuesta. Volviendo a mi editor de texto, todo lo que necesito hacer es encadenar el método de sincronización a la conexión, y luego puedo pasarle la propiedad de registro con el valor de la consola. Iniciar sesión. También puedo eliminar el método de autorización ya que llamar a la sincronización realizará la misma función. Luego iré a mi terminal y ejecutaré npm start. Y ahora puede ver que obtenemos la impresión SQL sin procesar que Sequelize usó para crear una nueva tabla llamada Usuarios y también crear columnas para un nombre y biografía que coinciden con nuestros atributos definidos anteriormente. También observe que tenemos algunas otras columnas aquí que son ID, createdAt y updated. Estas tres columnas siempre se agregan automáticamente cada vez que se crea una nueva tabla. CreatedAt y updatedAt contienen una marca de tiempo para cuando se creó o actualizó inicialmente una nueva fila de datos. El campo de ID es una clave principal que identifica de forma exclusiva una fila. Y pronto tendremos un video completo para comprender más sobre estas claves primarias. Con nuestra tabla de Usuarios creada, ahora demos el siguiente paso y agreguemos algunos datos.

Prueba con datos
Con nuestra tabla creada, agreguemos ahora una nueva fila de datos. Para agregar datos a una tabla, Sequelize nos proporciona el método de creación. Podemos ver un ejemplo de uso del método create en la página de inicio de los documentos de Sequelize. Para usarlo, solo necesitamos encadenar el método a nuestro modelo y luego pasarle los atributos definidos en nuestro modelo junto con los datos que queremos agregar. De vuelta en mi editor, usaré el método de creación en mi modelo de usuario después de que mi modelo se haya sincronizado. Dado que Sequelize se basa en promesas, puedo simplemente encadenar una función then. Y dentro de esta función, puedo llamar al método de creación en mi modelo de usuario. Necesitamos asegurarnos de usar los mismos atributos que ya se han declarado anteriormente con un nombre que es una cadena, junto con la biografía que también es una cadena. Abriré la ventana de mi consola ahora y cerraré mi servidor, y luego reiniciaré el servidor y veré los resultados. Y aquí puede ver que se ha agregado un nuevo usuario a nuestra tabla con los atributos que definimos dentro de create. Ahora, para ver mejor lo que hay dentro de nuestra base de datos, voy a descargar el navegador SQLite. Es una pequeña descarga compacta y está disponible para usuarios de Windows y Mac. Para seguirme, puede navegar hasta sqlitebrowser. org y elija la instalación adecuada para usted. Una vez que se completa la instalación, puede abrir el visor y debería verse así. Primero haremos clic en Abrir base de datos. Y desde allí seleccione la base de datos SQLite que existe actualmente en su proyecto. Y de inmediato puedo ver una descripción general de la estructura de la base de datos. Si hago clic en la pestaña Examinar datos, ahora podemos ver todas las tablas que se han creado junto con su estado. Actualmente, solo tenemos una tabla de Usuarios, e incluye la fila de datos recién formada que acabamos de agregar.

Tipos de datos
Al crear nuestros atributos, definimos pares clave y valor. Para cada atributo creado, debemos definir un tipo de datos que especifique qué tipo de datos están permitidos. Probablemente ya esté familiarizado con muchos de estos tipos de datos. Estos incluyen cadenas, enteros, fecha, matriz, booleano, entre muchos otros. Para obtener una lista completa de los tipos de datos permitidos por Sequelize, podemos ir a los documentos, buscar datos y luego hacer clic en Tipos de datos en Definición de modelo. Y aquí podemos ver una lista completa de todos los tipos de datos que podemos definir para cada uno de nuestros atributos. Observe cómo cada uno de estos tiene el prefijo de la palabra clave Sequelize. Ya ha estado asignando tipos de datos a atributos en nuestro modelo de usuario usando STRING y TEXT. TEXT es en realidad lo mismo que STRING excepto que permite el almacenamiento de una cadena de caracteres más larga. Siempre que agregue nuevos datos en una fila, debe coincidir con el tipo de datos definido en nuestro modelo. Entonces, por ejemplo, si intentáramos agregar una nueva fila de datos a nuestra tabla de Usuarios con un valor de matriz en lugar de una cadena, nuestro servidor se bloquea y los datos nunca se agregan.

Claves primarias
Las claves primarias son una característica esencial de todas las bases de datos SQL y tienen dos propósitos principales. Primero, identifican de forma única cada fila de datos que se envían a nuestra base de datos. Y, en segundo lugar, son el punto de referencia que se utiliza al formar asociaciones entre tablas. Y tendremos una sección completa sobre cómo formar estas asociaciones más adelante en este curso. Las claves primarias se generan automáticamente, se incrementan automáticamente y no pueden contener valores nulos. En el caso de Sequelize, una clave primaria se crea automáticamente bajo el nombre de columna de ID. Después de crear nuestro primer usuario, Sequelize asignó a la columna ID un valor de 1. Aquí agregué un nuevo usuario llamado Bob. Y el campo ID ahora tiene un valor de 2. Ahora tenemos la opción de definir una clave primaria con un nombre que no sea ID si queremos. Para mostrarte cómo se hace esto, buscaré los documentos de Sequelize para primarios y luego haré clic en Claves primarias. Aquí podemos encontrar dos ejemplos. En el primer ejemplo, tenemos un atributo llamado uid, y si necesitamos definir más de una propiedad para nuestro atributo, podemos usar un objeto. Siempre necesitamos definir el tipo. Entonces podemos usar la propiedad llamada primaryKey establecida en true. Y aquí se usa otra propiedad llamada autoIncrement para asegurarse de que los valores enteros se agreguen uno a la vez. Aquí hay otro ejemplo usando UUID. UUID es un tipo de datos que significa Identificador único universal de 36 caracteres de longitud. Así que sigamos adelante y probemos usando UUID dentro de nuestro modelo de usuario. De vuelta en mi editor, primero agregaré el conjunto de propiedades de fuerza para obtener una visión real de la sincronización. Esto eliminará mi tabla de Usuarios y luego la volverá a crear. Luego iré a mi modelo de usuario y crearé un nuevo atributo de UUID. Abra un objeto con una propiedad de tipo de UUID y una propiedad de primaryKey de true. También necesito agregar una propiedad adicional aquí de defaultValue con el tipo de UUIDV4. Si no asignamos este valor predeterminado aquí, esta columna será nula. Luego reiniciaré mi servidor. Y aquí puede ver en la consola que se creó un nuevo usuario con una columna UUID y un valor que contiene un identificador único.

Resumen
En este módulo, cubrimos todos los requisitos para comenzar con el proyecto Sequelize. Comenzamos conectando nuestro proyecto a una base de datos SQLite. Luego, construimos un modelo de usuario que se transformó en una tabla SQL. Agregó nuevos datos a nuestra tabla de Usuarios usando el método de creación y observó la salida en nuestro visor de base de datos. Y, finalmente, se familiarizó con los tipos de datos que se pueden enviar, junto con el propósito de las claves primarias. Ha recorrido un largo camino y ahora está muy familiarizado con los componentes esenciales de Sequelize. A continuación, discutiremos cómo personalizar los atributos de nuestro modelo y realizar la validación.

Personalizar y validar
Introducción
Hola y bienvenido de nuevo a Introducción a Sequelize ORM para Node. js. Hasta ahora, hemos creado un nuevo proyecto Sequelize y hemos agregado un modelo de Usuarios con dos atributos. La mayoría de las veces, no queremos simplemente enviar a nuestra base de datos cualquier dato que se nos presente. Es posible que primero deseemos realizar alguna validación, como asegurarnos de que nuestro usuario haya enviado un correo electrónico válido. En este módulo, cubriremos las opciones disponibles para nosotros para personalizar nuestro modelo, cómo realizar la validación de los atributos antes de que los datos se agreguen a una base de datos y cómo usar los ganchos de antes y después para cifrar o personalizar los datos antes de que lleguen a nuestra base de datos.

Personalizar modelo
Sequelize nos proporciona algunas propiedades opcionales que podemos usar para personalizar nuestro modelo. Uno de estos se llama freezeTableName. Cuando esta propiedad se agrega a nuestro modelo y se establece en verdadero, el nombre que le damos a nuestro modelo coincidirá con el nombre de nuestra tabla. Vayamos ahora a los documentos para que pueda ver las diferentes opciones disponibles, y luego agregaremos algunas de estas a nuestro modelo de usuario existente. Puedo buscar en los documentos que se puedan congelar, y luego tenemos que desplazarnos un poco hacia abajo hasta llegar a las opciones. Y aquí es donde encontramos todas las diferentes opciones de propiedad que podemos usar en nuestro modelo. Aquí hay una opción para las marcas de tiempo. Es un booleano, y cuando se establece en falso, nuestras marcas de tiempo createdAt y updatedAt no se crearán automáticamente. Aquí está la opción freezeTableName. Cuando se establece en verdadero, el nombre de nuestra tabla no se pluralizará. Agreguemos ahora algunas de estas propiedades a nuestro modelo de usuario. Las propiedades de las opciones que acabamos de ver son en realidad parte del método de definición. Eso significa que podemos agregarlos globalmente para que se agreguen a cada modelo que creamos o simplemente a un modelo específico. Para agregar estas opciones globalmente, puedo agregar una nueva propiedad a mi objeto Sequelize llamada define, y esta definición es la misma que el método define que se usa en nuestro modelo. Luego, dentro de nuestra definición de Sequelize, puedo abrir un objeto y agregar cualquier propiedad aquí. Así que solo agregaremos freezeTableName establecido en verdadero. Asegúrese de que su método de sincronización todavía tenga la fuerza establecida en verdadero para que sus tablas se eliminen. Y luego inicie el servidor. Y aquí puede ver que el nombre de la tabla ahora coincide con el nombre del modelo. Agreguemos una opción más directamente en nuestro modelo. Cuando usamos cualquiera de estas opciones en nuestro modelo, tenemos que declararlas en un tercer parámetro como propiedades en un objeto. Elegiremos la propiedad timeStamps establecida en false. Luego mataré y reiniciaré mi servidor. Y aquí puede ver que nuestra tabla de usuarios no creó un campo updatedAt o createdAt.

Calificadores de atributos
Sequelize nos proporciona algunos calificadores de propiedades de atributos que nos permiten personalizar los atributos antes de que se conviertan en columnas. Estas incluyen propiedades que se utilizan para asignar una clave principal, asignar un valor predeterminado o para asegurarse de que los datos enviados no sean nulos. Si decidimos utilizar una de estas propiedades, se colocan en un objeto en el campo de valor de un nombre de atributo. Dentro de este objeto, siempre debemos especificar primero el tipo de datos, y luego podemos seguir adelante y colocar cualquiera de los calificadores preaprobados a continuación. Ya usó algunos de estos en nuestro modelo de usuario en la sección anterior, como cuando colocamos una propiedad de clave principal en el atributo de ID de usuario y asignamos un valor predeterminado de UUIDV4. Al definir las otras opciones de propiedad disponibles para nosotros, puedo buscar los documentos para congelar, lo que nos lleva a una lista de opciones disponibles. Observe cómo se definen mediante la notación de atributos con puntos. columna y luego el nombre de la propiedad utilizada en nuestro atributo. Los tres que usará con más frecuencia ya los hemos discutido, y estos son allowNull, que se usan cuando queremos asegurarnos de que la columna contiene algunos datos, defaultValue y primaryKey. Ahora, si nos desplazamos un poco hacia abajo, llegamos a los atributos. validar. Y esta es la propiedad que usaremos para realizar muchos tipos de validación en nuestro atributo.

Validaciones
Es posible que deseemos validar los datos a medida que ingresan para asegurarnos de que coincidan con nuestros requisitos. Sequelize facilita la realización de este tipo de validaciones mediante la implementación de una larga lista de validadores de validadores. js. Volviendo a los documentos de Sequelize, recuerde, nos dimos cuenta de esta propiedad de validación. La descripción aquí dice que validar es un objeto de validaciones para ejecutar para esta columna cada vez que se guarda el modelo. Puede ser el nombre de una validación proporcionada por el validador. js, una función de validación proporcionada al extender validator. js, o una función de validación personalizada. Para encontrar todas las posibles validaciones proporcionadas por el validador. js, puedo buscar validaciones en los documentos y hacer clic en el enlace debajo de Definición del modelo. Esto nos lleva a una página de explicación y ejemplo sobre cómo implementar una gran cantidad de diferentes tipos de validaciones. Estas validaciones integradas le permiten verificar fácilmente si la entrada está en forma válida. Por ejemplo, puede verificar si el usuario ha enviado una dirección de correo electrónico válida, una URL con el formato correcto o números de tarjeta de crédito válidos. Para ejecutar la validación, primero debemos agregar la propiedad de validación a un atributo existente actualmente, y luego podemos agregar cualquier número de estas propiedades de validación. Si los datos enviados no cumplen con la restricción especificada, el validador enviará un mensaje de error personalizado o podemos crear nuestro propio mensaje. Si queremos crear nuestro propio mensaje de error, debe estar en este formato, entonces, primero, un validador que estemos usando, y luego un objeto con una propiedad llamada args, que contiene la validación real que queremos realizar, junto con con una propiedad msg con una cadena de lo que debería ser el mensaje de error en la validación fallida. Probemos ahora esto y agreguemos algunos validadores a nuestro modelo de usuario. Agregaré un nuevo validador a mi atributo de nombre abriendo un objeto y declarando un tipo de STRING. Luego agregaré una de mis propiedades de validación. Ahora, para agregar cualquiera de las opciones del validador, necesito establecer el valor como un objeto. Y usemos el validador de len aquí. Entonces len acepta una matriz de dos valores. El primer valor especificará el número mínimo de caracteres necesarios para que pase la validación, por lo que pondremos 3. El segundo valor es opcional y especificará el número máximo de caracteres permitidos. Como quiero no permitir valores máximos, lo dejaré en blanco. Voy a agregar otro validador aquí a mi atributo bio. Usaremos el validador llamado contains para que nuestro contenido contenga la palabra foo. Pero, pensándolo bien, quiero asegurarme y enviar un mensaje muy claro de por qué esta validación falló. Para hacer eso, necesito convertir el valor de contains en un objeto con un argumento y una propiedad de mensaje. El mensaje le permitirá al usuario saber que hay un error de validación y que el campo debe contener foo. Para ver nuestra validación fallida, podríamos usar un método de captura después de crear un nuevo usuario y luego cerrar la sesión del cónsul, pero en realidad será mucho más fácil ver qué salió mal si usamos una ruta Express y luego envíe el mensaje como JSON para verlo en nuestro navegador. Así que voy a crear una nueva ruta usando la aplicación. get, los dos parámetros de req y res, que contendrán nuestros objetos de solicitud y respuesta, luego copie mi usuario desde abajo, asegurándose de comentar esta área. Luego pégalo en mi ruta. Luego edite mi nombre de usuario a Jo para que falle la validación. Y cuando se crea el usuario, enviaré la respuesta a mi vista en JSON. Y si hay un error, cerraré la sesión del error en mi terminal y también enviaré el error a mi navegador junto con el código de estado 0404. Ahora, cuando inicio mi servidor y cargo mi aplicación en localhost 8001, aquí podemos ver un objeto con ambos mensajes de error, Error de validación en nombre. Y luego tenemos otro objeto de error con el mensaje más útil, Error de validación, el campo debe contener foo. El uso de la propiedad de validación es una forma sencilla de realizar muchos tipos de validaciones en nuestros atributos. Analicemos ahora un método Sequelize para modificar datos antes de que lleguen a nuestra base de datos mediante ganchos.

Manos
Hay ocasiones en las que es posible que deseemos modificar los datos antes de que lleguen a la base de datos. En estos casos, Sequelize nos proporciona una función llamada hooks. Los enganches, también conocidos como eventos del ciclo de vida, se llaman antes y después de que se ejecuten los eventos en Sequelize. Hay cuatro eventos internos diferentes del ciclo de vida de Sequelize que podemos aprovechar. BeforeValidate se utiliza antes de que se produzca la validación. AfterValidate se utiliza una vez realizada la validación. BeforeCreate se usa después de la validación pero antes de que se hayan creado los datos de la columna. Y afterCreate, que se utiliza después de que se hayan creado los datos de la columna. Para usar un gancho, agregamos los ganchos de propiedad como tercer parámetro a nuestro modelo después de que se hayan declarado todos nuestros atributos. Los cuatro de nuestros ganchos se utilizan como función. Los primeros tres tipos de ganchos aceptan un parámetro que representa el objeto modelo, mientras que el gancho afterCreate también acepta un parámetro que representa el objeto de respuesta final. Un caso de uso común para los ganchos es cuando necesitamos codificar la contraseña de un usuario antes de enviarla a la base de datos. Veamos ahora algunos ejemplos del uso de ganchos dentro de nuestro proyecto. En nuestro modelo de usuario, primero eliminaré la validación del nombre y la biografía. Voy a cambiar los atributos de nombre a primero, luego agregar un nuevo atributo de último con el tipo de STRING junto con otro atributo llamado full_name, también con un tipo de STRING. Definimos nuestros ganchos como un tercer parámetro de la definición de nuestro modelo. Actualmente estamos configurando timeStamps en falso en nuestro tercer parámetro. Así que voy a cambiar esto para declarar nuestras funciones de gancho. Luego, solo agregaré nuestros cuatro tipos diferentes de ganchos y cerraré la sesión con un mensaje apropiado para cada uno. También necesito crear un nuevo usuario para que podamos ver estos mensajes de registro. Así que simplemente me desplazaré hacia abajo debajo de mi método de sincronización, encadenaré una función luego, creando nuestro usuario con un primer, un último y una biografía. Ahora ejecutaré mi servidor y comprobaré la respuesta. Aquí puede ver los distintos mensajes de registro correspondientes a cada parte del proceso del ciclo de vida. Probemos ahora un ejemplo simple usando el gancho beforeCreate. Así que quiero tomar los valores para el primero y el último y combinarlos para completar el campo de atributo full_name. BeforeCreate acepta un parámetro que representa nuestro modelo de usuario. Luego, dentro del cuerpo de esta función, solo voy a combinar el nombre y apellido del usuario. Aquí estoy usando comillas invertidas de ES6 e interpolación de cadenas. Ahora simplemente mataré y reiniciaré mi servidor. Y aquí puede ver la creación de una nueva tabla con una columna de nombre completo que incluye el nombre Joe Smith.

revisión
En este módulo, analizamos las diferentes formas en que podemos modificar, validar y personalizar los datos antes de enviarlos a nuestra base de datos. Primero revisamos algunas de las propiedades integradas que podemos declarar en un tercer parámetro utilizado para modificar nuestro modelo. Estos incluyen el uso de las propiedades de timeStamps y freezeTableName. A continuación, analizamos algunos de los calificadores de atributos integrados, como allowNull, primaryKey y defaultValue. Luego discutimos cómo realizar validaciones en nuestros atributos usando el validador. js propiedades. Esto nos proporcionó validadores integrados fáciles de implementar que se colocaron en los campos de valor de un atributo de destino. Y, finalmente, discutimos cómo podemos usar las funciones de hooks para modificar datos antes de que se envíen a nuestra base de datos. Ahora que tenemos los conceptos básicos para configurar un proyecto, agregar un modelo y enviar datos, ahora aprendamos cómo realizar operaciones CRUD para consultar y actualizar nuestros datos.

Realización de operaciones CRUD
Introducción
Hola. Mi nombre es Patrick Schroeder y me gustaría darle la bienvenida nuevamente a Introducción a Sequelize ORM para Node. js. Hasta ahora, ha aprendido a crear una aplicación Node. js que usa Sequelize para interactuar con una base de datos SQL. Luego, dominó cómo construir modelos de Sequelize que se mapean en tablas SQL. En este módulo, aprenderá cómo interactuar con las entradas de la base de datos para realizar operaciones CRUD, para crear, leer, actualizar y eliminar elementos de la base de datos. Primero comenzaremos con una importación masiva de elementos de la base de datos para que tengamos algunos datos con los que trabajar. Luego veremos cinco métodos de Sequelize diferentes que harán el trabajo de recuperar, actualizar y eliminar elementos. Para estos ejemplos, crearé diferentes puntos finales de API en nuestro proyecto usando Express, y luego mostraré los resultados de nuestras solicitudes dentro de la ventana de nuestro navegador. Estos puntos finales de API serán muy similares a los puntos finales de API reales que usaremos en nuestro proyecto final.

Agregar datos de muestra
Primero voy a generar algunos datos de muestra para nuestra base de datos. Esto se hará usando el sitio web generatedata. com. Tenga en cuenta que esto es solo para fines de ejemplo, y es una manera fácil para nosotros de insertar algunos datos simulados. Los nombres de mis columnas serán nombre, correo electrónico y contraseña. Los tipos de datos serán Nombres, Correo electrónico y Alfanumérico. En los ejemplos, seleccionaré Contraseñas para la columna de contraseña y Alex de cualquier género. La exportación aquí será JSON con una estructura de datos simple. Generaré 100 filas y cambiaré la salida a Solicitar descarga, y luego haré clic en el botón Generar. Luego abriré este archivo recién generado dentro de mi código de Visual Studio y guardaré este archivo como usuarios. json en la raíz de la carpeta de mi proyecto. Puede ver aquí que este archivo es una matriz de objetos JSON con claves de nombre, correo electrónico y contraseña. Modifiquemos ahora nuestro atributo de modelo de Usuarios para que coincida con los valores aquí. Así que de vuelta en mi servidor. js, comenzaré requiriendo en mi archivo \_USERS hacer referencia a él con una variable de \_users. A continuación, me desplazaré hacia abajo en mi modelo de Usuarios y agregaré los atributos para que coincidan con lo que hay en los usuarios. json archivo. Así que eliminaré los atributos enumerados actualmente, luego agregaré un atributo de nombre, que es del tipo STRING. Agregaré un atributo de correo electrónico con un tipo de STRING y también incluiré una propiedad de validación que verifique que sea un correo electrónico válido. Luego agregaré un atributo de contraseña con un tipo de CADENA, y también agregaré una propiedad de validación para verificar que los datos sean alfanuméricos. Ahora puedo importar los datos de mis usuarios a una tabla de Usuarios llamando al método bulkCreate. Echemos un vistazo a los documentos rápidamente y veamos una definición primero buscando bulkCreate. Y puede ver aquí que acepta una matriz de registros con un segundo argumento opcional. Y este método creará e insertará varias instancias de forma masiva. Muy claro. Volviendo a mi código, puedo encadenar un método then en sincronización llamando a bulkCreate en mi modelo de usuario y pasando nuestra referencia \_USERS que importamos anteriormente. Si tiene éxito, imprimiré un mensaje de registro. Y en caso de error, simplemente enviaré el error a la consola. Voy a eliminar la opción de fuerza ya que no quiero quitar la tabla después de que se haya creado inicialmente. Y también voy a comentar la parte de registro para poder ver fácilmente el mensaje de éxito en mi consola. Y ahora reiniciaré mi servidor. Recibimos el mensaje de éxito en mi consola y voy a ver el conjunto de datos resultante dentro del navegador SQLite. Abra la base de datos en nuestra carpeta, luego haga clic en Examinar datos. Y aquí puede ver las 100 filas de usuarios que se han agregado a mi base de datos.

Crear método
Para agregar un elemento a nuestra base de datos, Sequelize nos da el método de creación. Ya hemos utilizado el método de creación varias veces al agregar elementos a nuestra base de datos. Entonces, para este ejemplo, simplemente lo guiaré a través de una solicitud de publicación típica realizada a una API Express. Este será un pseudocódigo ya que todavía no tenemos un cliente. En mi código, primero cambiaré la ruta aquí de índice a publicación, y luego cambiaré la solicitud de llegar a publicación. Por lo general, recibiremos algunos datos de nuestro cliente y podemos acceder a esos datos mediante el parámetro req. Así que crearé una nueva variable aquí llamada newUser y la estableceré en igual req. cuerpo. usuario. El cuerpo es un parámetro en el objeto de solicitud que usamos para obtener los datos que se nos envían. Y luego podemos enviar el objeto newUser dentro de nuestro parámetro de creación. Y esto funciona bien, pero si prefiere más claridad, puede pasar un objeto y especificar primero los atributos en nuestro modelo con los valores que se pasan desde nuestro objeto newUser. Ahora tenga en cuenta que esto es solo un pseudocódigo, y esta ruta no funcionará. Solo está destinado a prepararte para el aspecto que tendrá nuestro método de publicación en nuestra aplicación de ejemplo.

Buscar todo y filtrar
Para consultar nuestra base de datos, Sequelize nos proporciona el método findAll. Con este método, podemos recuperar todas las filas de una tabla específica, y también podemos filtrar datos usando el operador where. En este video, crearemos una ruta Express y mostraremos los resultados en nuestro navegador. De vuelta en mi código, primero quiero comentar el código que crea mis usuarios masivos. Ahora iré debajo de mi modelo de usuario y crearé una nueva ruta usando el método get Express nombrando esta ruta findAll. Y luego agregaré mi función con los parámetros req y res. Dentro de la función, usaré mi modelo y cadena de usuario en el método findAll. En este punto, puedo simplemente invocar el método, que recuperará todos los registros de la base de datos ubicados en la tabla Usuarios. Copiaré el entonces y atraparé a los manejadores de arriba. Probemos esto reiniciando el servidor y navegando hasta localhost: 8001 / findall. Y aquí podemos ver la impresión JSON de todos los usuarios en mi tabla de base de datos SQLite. Bien, eso es genial si queremos recuperar a todos los usuarios en nuestra tabla. Pero, ¿y si queremos solo un determinado subconjunto de usuarios? Para este tipo de escenarios, Sequelize nos proporciona el operador where. De vuelta en mi código, agregaré un par de llaves para crear un nuevo objeto. Observe que aquí podemos colocar el cursor sobre el método findAll y obtenemos un excelente IntelliSense que explica exactamente lo que hace este método. Cuando usamos findAll, podemos buscar múltiples instancias de una fila de tabla usando el objeto where. Dentro de este objeto where, podemos agregar claves que coincidan con cualquiera de nuestros atributos junto con el valor de lo que queremos buscar. Podemos ver aquí que hay una serie de operadores que podemos pasar para refinar nuestra consulta. Se puede encontrar una lista completa de estos operadores en los documentos de Sequelize buscando dónde, luego desplazándose un poco hacia abajo para encontrar los diferentes operadores. Para usar cualquiera de estos operadores, primero necesitaremos incluir una referencia al método Op en Sequelize, y luego envolver el operador que queremos usar en una matriz con el prefijo Op. De vuelta en nuestro código, probemos esta funcionalidad donde pasando nuestro atributo de nombre junto con el valor de David. Reiniciaré mi servidor y actualizaré la página, y aquí pueden ver que recuperamos el registro único con el nombre de David. Ahora hagamos un ejemplo usando uno de nuestros operadores. Para este ejemplo, recuperemos todos los registros del atributo de nombre que comienza con D-A-V. Entonces, primero, para usar el método Op para reducir la consulta, necesito importarlo desde Sequelize en la parte superior de mi archivo. Ahora, para filtrar los atributos de mi nombre, necesito cambiar el valor del nombre en un objeto. Luego, necesito definir mi clave Op en una matriz. Y cuando agrego el punto, puedes ver un montón de métodos posibles que aparecen. Usaré el método similar para hacer coincidir todos los registros que comienzan con D-A-V. El signo de porcentaje al final actúa como un comodín. Por lo tanto, aparecerán las entradas que comiencen con D-A-V más cualquier otro valor. Luego reiniciaré mi servidor, navegaré de regreso a mi ruta, y aquí pueden ver que obtenemos solo las dos entradas con los atributos de nombre que comienzan con D-A-V. Así que ahora me gustaría animarle a que se tome un minuto aquí y pruebe algunos de los otros operadores basándose en lo que hay en su propio archivo de base de datos y observe los resultados en su navegador. Y cuando haya terminado, me reuniré con usted en la próxima lección para discutir cómo encontrar un solo registro usando el método findById.

Encuentra una entrada
A cada fila de datos que se inserta en nuestra tabla se le asigna automáticamente una clave principal que sirve como identificador único para esa fila. En Sequelize, estos se agregan a la columna ID. Comienzan con el número 1 y se incrementan automáticamente. Podemos usar estos identificadores únicos para consultar fácilmente un registro específico usando el método findById. De vuelta en nuestro código, probemos el método findById creando una nueva ruta. Esta será una solicitud de obtención en la ubicación de / findOne. El segundo parámetro aquí es el mismo que el anterior. Es una función que toma req y res como argumentos. Luego, encadenaremos un método findById a nuestro modelo de usuario, pasando la clave principal del registro que queremos ver. Copiaré nuestras respuestas de éxito y error de arriba, luego reiniciaré el servidor, y cuando navegue hacia localhost: 8001 / findOne, aquí puede ver que recuperamos a nuestro usuario con la ID de 55.

Actualizar entrada
Para actualizar cualquier fila de nuestra tabla, Sequelize nos proporciona el método de actualización. Para actualizar un elemento, primero llamamos al método update en nuestro modelo, siendo el primer parámetro de este método los atributos que queremos actualizar. Este ejemplo actualiza el nombre y la contraseña del usuario. El segundo parámetro encontrará la entrada que queremos actualizar usando el operador where. Cuando usamos where, podemos pasarle un objeto con la clave como el nombre del atributo. En este ejemplo, estamos pasando req. params. carné de identidad. Entonces, en una aplicación típica, obtendremos el valor de ID del atributo de un parámetro en la URL usando Express, y así es como lo hacemos. Una advertencia aquí es que no recuperaremos el objeto del usuario actualizado en la respuesta de éxito. Sequelize solo enviará esto de vuelta la cantidad de atributos que fueron afectados por la actualización. Y es por eso que nombré la respuesta aquí como filas. Ahora saltemos al código y trabajemos con nuestro ejemplo. Primero copiaré la ruta findOne que ya hemos definido y la convertiré en una ruta de actualización. Cambiaré la ruta para señalar para actualizar y cambiaré la solicitud para que sea una solicitud de colocación. Y luego cambiaré el método findById para actualizarlo. El primer parámetro aquí es un objeto. Normalmente enviaremos datos del cliente, que serán requeridos. body, pero en nuestro caso de prueba, codificaremos algunos datos declarando un objeto con el nombre de Michael Keaton, y también una contraseña llamada contraseña. El segundo parámetro consulta la tabla usando el operador where y apuntando a una ID de nuestra elección. En este caso, cambiaremos el usuario con un ID de 55 para que podamos compararlo con nuestra ruta findOne. Luego, cambiaré mi respuesta de usuario a filas, ya que solo obtendremos una cantidad de filas afectadas de la respuesta. Recuerda que actualmente nuestro usuario con ID 55 se llama Christian. Entonces, si el nombre se cambia a Michael Keaton, sabemos que está funcionando. Y ahora, iniciemos nuestro servidor. Para probar esta nueva ruta de venta, tendré que usar Postman en lugar de Chrome. Así que aquí abrí la aplicación independiente Postman, que me permite ejecutar pruebas en diferentes puntos finales de API y ver los resultados. Quiero ejecutar una solicitud de colocación en localhost: 8001 / update. Entonces puedo hacer clic en enviar. Aquí puede ver que tenemos una salida de matriz de 1 y un código de estado de 200. Entonces parece que funcionó, y cuando actualizamos nuestra ruta findOne, puede ver que el nombre de nuestro usuario se actualizó a Michael Keaton como se esperaba. . Ahora ha aprendido a crear, leer y actualizar elementos de la base de datos usando Sequelize. ¡Buen trabajo! Ahora es el momento de la última pieza del rompecabezas CRUD: eliminar las entradas de la base de datos.

Eliminar la entrada
Para eliminar un elemento de nuestra base de datos, Sequelize nos proporciona el método de destrucción. Podemos usar destroy de manera muy similar a findById. Entonces, para este ejemplo, copiaré la ruta findOne que definimos aquí y luego cambiaré el nombre de la ruta para eliminar y cambiar el método de solicitud para eliminar y luego cambiar findById para destruir. Destroy acepta solo un parámetro, un objeto que apunta al registro que queremos eliminar. Podemos ubicar al usuario que queremos eliminar usando el operador where, y luego usar un objeto para especificar el atributo de ID que queremos borrar, que será el usuario con un ID de 50. En caso de éxito, no obtendremos nada a cambio. Entonces puedo eliminar el objeto de respuesta y, en su lugar, solo enviaré un mensaje al cliente diciendo que el usuario se eliminó correctamente. Ahora iniciemos el servidor y probemos nuestra nueva ruta. Para este ejemplo, necesito usar Postman nuevamente para realizar la solicitud de eliminación. Así que abriré Postman, cambiaré la solicitud para eliminar, luego agregaré mi nueva ruta, que es localhost: 8001 / remove, y haré clic en enviar. Y aquí puede ver que recibimos el mensaje de éxito que indica que nuestro usuario ha sido eliminado. Si desea volver a verificar, puede abrir el visor de la base de datos SQLite. Y observe aquí que el usuario con un ID de 50 ha sido eliminado.

Resumen
En este módulo, discutimos los métodos de Sequelize que podemos usar para realizar operaciones CRUD para crear, leer, actualizar y eliminar entradas de la base de datos. Usamos los métodos create y bulkCreate para agregar elementos a nuestra base de datos. Luego usamos el método de consulta findAll para tomar todos los registros de nuestra tabla de Usuarios. El método findOne se utilizó para encontrar un usuario específico en función de su ID. El método de actualización se utilizó para actualizar una entrada. El primer parámetro fue un objeto que contenía los atributos que queríamos actualizar. Y, finalmente, usamos el método de destrucción para eliminar un usuario de nuestra base de datos. En este punto, tiene un proyecto configurado, un modelo en su lugar y una comprensión de cómo realizar operaciones CRUD. Y ahora, la última pieza del rompecabezas de Sequelize es comprender cómo crear asociaciones entre tablas.

Asociaciones
Introducción
Bienvenido de nuevo a Introducción a Sequelize ORM para Node. js. En este punto, ya ha aprendido casi todos los aspectos básicos de cómo crear una aplicación basada en SQL utilizando Sequelize. Tenemos un tema más muy importante que cubrir, que son las asociaciones. En este módulo, aprenderá qué son las asociaciones y cómo se utilizan para crear combinaciones de tablas. Cubriremos los tres tipos diferentes de asociaciones que se pueden realizar. Estos incluyen asociaciones uno a uno, asociaciones uno a muchos y asociaciones de muchos a muchos. Cubriremos los cuatro métodos diferentes que Sequelize nos brinda para crear estas asociaciones. Y luego usaremos cada uno de estos métodos en nuestro proyecto para construir una API usando Express.

Asociaciones explicadas
Entonces, ¿qué son exactamente las asociaciones? Las asociaciones forman relaciones entre tablas. Estas relaciones se utilizan para crear combinaciones de tablas. Una combinación en SQL simplemente fusiona datos entre dos tablas diferentes. Entonces, por ejemplo, puede tener una tabla de Usuarios y una tabla de Publicaciones. Cada tabla contiene un ID que es su clave principal, junto con algunos otros atributos. En mi tabla de Publicaciones, es posible que desee guardar una referencia al usuario que hizo la Publicación. Todo lo que necesito hacer es agregar una columna que contenga la clave principal del usuario. Y luego, cada vez que se recupera esa publicación de la base de datos, también recupero al usuario con los atributos que desee. La respuesta se vería así. Recibo mi publicación con una identificación junto con el título y algo de contenido. También hemos guardado una referencia al usuario que tiene un ID de 2. Además, recuperamos ese usuario junto con sus atributos. La creación de una asociación entre tablas es un proceso de dos partes. Primero, definimos nuestra asociación entre modelos. En nuestro ejemplo actual, decimos Publicar. pertenece a (usuario). BelongsTo es uno de los métodos que Sequelize nos da para formar estas asociaciones. Esta línea de código se agrega después de definir nuestros modelos. Al formar esta asociación, se agregará automáticamente una columna userId a la tabla Publicaciones. Y, en segundo lugar, cada vez que realizamos una consulta en nuestra tabla Publicaciones, debemos agregar la propiedad de inclusión dentro de la consulta con el modelo asociado como valor. Entonces, si quisiéramos obtener una sola publicación por su ID, también incluiríamos el modelo de usuario en una matriz como esta. En este ejemplo, obtendríamos todos los atributos de los usuarios. Si, en cambio, solo quisiéramos recuperar ciertos atributos, entonces envolveríamos el valor de nuestra inclusión en un objeto, primero, especificando el modelo y luego el atributo. Aquí solo obtendríamos el nombre del usuario junto con la entrada Publicar. Agreguemos ahora una asociación ApplicaTo entre Usuario y Publicación en nuestro proyecto.

Agregar la Asociación Pertenece a ()
Ahora que comprende los conceptos básicos de la formación de asociaciones entre modelos, creemos un nuevo modelo llamado Publicar y creemos una asociación con el usuario. De vuelta en nuestro código, lo primero que haré es eliminar todas mis rutas CRUD excepto la ruta findAll, que estaremos editando. Ahora crearé un nuevo modelo llamado Publicar. Para este modelo, definiré el ID como su PrimaryKey. Entonces también necesito agregar un valor predeterminado con un tipo de UUIDV4. Y luego agregaré dos atributos: título de tipo CADENA y el contenido de tipo TEXTO. Luego, me desplazaré hacia abajo y colocaré mi asociación justo encima de la conexión que dice Publicar. pertenece al usuario que pasa. También agregaré un comentario aquí indicando que este método agregará una ForeignKey llamada UserId en la tabla de publicaciones. Podemos probar la asociación creando una nueva publicación con un atributo de UserId establecido en 1 junto con un título y contenido. Ahora creemos una nueva ruta para que podamos ver los datos. Solo editaré la ruta findAll existente, renombrándola para que sea allposts, luego, dentro de la función, llamaré findAll on Post. Reemplazaré la instrucción where con nuestra propiedad include que hace referencia a mi modelo de usuario y cambiaré el objeto de respuesta para que coincida con el nombre de nuestra respuesta. Ahora, con todo configurado, puedo reiniciar mi servidor. Y, primero, verificaré mi base de datos. Y aquí puede ver que se ha creado una tabla de publicaciones con una referencia al usuario con un ID de 1. En mi tabla de Usuarios, el usuario con un ID de 1 se llama Hakeem. Así que ahora naveguemos hacia nuestras rutas de allposts, y aquí puede ver que el objeto de respuesta es nuestra publicación recién creada junto con nuestro usuario Hakeem y sus otros atributos.

Llaves extranjeras
Al construir nuestra asociación ApplicaTo, se creó una columna UserId. Esto es lo que se conoce como clave externa. La clave externa se genera automáticamente para nosotros y está en mayúscula Pascal. Sin embargo, es posible que deseemos darle a nuestra clave externa un nombre de nuestra propia elección. Para hacer esto, todo lo que necesitamos hacer es agregar un objeto como el segundo argumento de nuestro método pertenece a con una clave de ForeignKey y un valor de lo que queramos que sea el nombre. Volvamos a nuestro proyecto y personalicemos nuestra asociación actual. Agregaré una coma después de User, definiré un objeto con una clave de ForeignKey y un valor de userId en minúsculas. Luego, descomentaré la fuerza establecida en verdadero para que mis tablas se eliminen. Descomentaré la función bulkCreate para que se agreguen mis usuarios. Y comenta nuestro proyecto. crear función. Luego ejecutaré mi servidor, abriré el visor de base de datos y aquí puede ver que se ha agregado una clave externa de userId en minúsculas a mi tabla de Publicaciones.

Alias ​​del modelo
A veces, al crear asociaciones, tiene sentido crear un alias para nuestro modelo. Un alias cambiará el nombre del modelo cuando se utilice como asociación. Entonces, por ejemplo, en nuestra respuesta de publicación actual, obtenemos un usuario con sus atributos. Es posible que deseemos cambiar el nombre de Usuario a otra cosa en nuestra respuesta, como UserRef. Para hacer esto, primero necesitamos agregar un par clave-valor a nuestro objeto. La palabra clave as es la clave que crea el alias y el valor es el nombre de nuestro alias. Además, también debemos asegurarnos de que cada vez que incluyamos el modelo de usuario en nuestra consulta, hagamos referencia al alias usando la propiedad as. Ahora que comprende cómo crear un alias, probémoslo en nuestro proyecto. De nuevo en mi proyecto, agregaré mi alias usando la propiedad as, más el nombre de mi alias, que será UserRef. A continuación, cambiaré cómo incluyo a mi usuario en mi ruta allposts convirtiendo la referencia de inclusión en un objeto. Este contendrá una clave de modelo y luego hará referencia primero al modelo de usuario con un alias de UserRef. Ahora, para probar esto, necesito hacer un par de ajustes a continuación. Entonces, primero, cortaré y pegaré mi función bulkCreate justo debajo de sync y descomentaré el bloque. Luego, descomentaré mi publicación. crear la función y cambiar el atributo UserId a minúsculas para que coincida con mi clave externa recién cambiada. Ahora puedo reiniciar mi servidor y navegar hasta mi ruta allposts. Y aquí puede ver que mi objeto de devolución ahora se ha actualizado de User a UserRef.
Tipos de asociaciones
Hasta ahora solo hemos hablado de un tipo de asociación. Se trataba de una asociación uno a uno de Publicar en usuario. Pero en realidad hay tres tipos diferentes de asociaciones que podemos formar entre nuestras tablas. Además de una asociación de uno a uno, también podemos formar una asociación de uno a muchos o una asociación de muchos a muchos. Para comprender las diferencias entre estos, comparemos cada uno. Al formar una asociación uno a uno, usamos el método pertenece a o el método hasOne. HasOne es esencialmente lo mismo que pertenece a excepto que coloca la clave externa en la tabla opuesta. Entonces, en nuestro ejemplo de Publicar en usuario, una clave externa de PostId se colocaría en la tabla Usuarios cuando se usa el método hasOne. Cuando nuestro modelo asociado se recupera usando una clave externa, siempre solo recibiremos un solo artículo. Para formar una asociación de uno a muchos, usamos el método hasMany. La sintaxis del método para crear una asociación hasMany parece idéntica a la de pertenece a o de hasOne. En una asociación de uno a muchos, un usuario de este ejemplo puede tener muchas publicaciones. Entonces, para cada publicación realizada, se colocará una clave externa de UserId en la tabla de publicaciones. Cuando se crea un usuario, recibimos una serie de Publicaciones para todas las Publicaciones individuales que ha realizado un usuario asociado. En una asociación de muchos a muchos, usamos el método pertenece a muchos. When forming this type of association, we use the belongsToMany method on both models. This will then create a join table that contains just two columns. Each column will contain the primary key reference for each of the models. The response that we get back when either of these tables is included will always be an array of items. Let's now fully walk through building a one-to-many association.

One-to-Many Association
Building a one-to-many association is very similar to building a one-to-one association. You first need to define the association between models using the hasMany method. In this example, a Post can have many comments. When the association is created, a foreign key of PostId will be added to the Comments table. You can optionally add an alias or a foreign key as a second parameter. When making a request, you must include the associated model, along with an alias if there is one. The response we get back when making a query on Post will contain an array of all of the comments that have been added. Let's now jump in the code and build a hasMany association. I'm going to make a couple of adjustments here first. I'm going to remove this freezeTableName property in our connection, so now we'll get the pluralized table names created. I'm also going to remove this ID field from Post. This will just make it easier to reference a PostId when we create our new comments. Now I'm going to create a new Comments model. It will have just one attribute called the_comment of type STRING. and now let's create a new association for Post to Comment. Since a Post can have many comments, I will say Post. hasMany passing in my Comments model along with an alias of All_Comments. I'll also make a note here saying that a foreign key of PostId will be placed in the Comments table. Now let's create our route. I'll just copy over this allposts route and then make a couple of edits. It's going to be a Get request made to a route named singlepost. Inside my function, I'll reference the Post model and use the findById method. We'll find the Post with an ID of 1. Then in order to get back all the comments associated with this Post, I'll include the model along with an alias. And I only want to get back the attribute of the_comment. Now let's create some mock data. I'll still be creating a bulk users here. Then we'll create three new Posts. To do this, I'll copy over my first Post creation two more times. The first two Posts will be associated with our user of an ID of 1. The third Post will reference the user with an ID of 2. And then I'll also create two new comments. So I'll this copy these from Post and then edit. Remember that the Comments model now contains a reference to a Post in the form of a foreign key named a PostId. We'll set both of these to the Post with an ID of 1. And then I'll put in some filler text for each of the new comments. I forgot to adjust my Post title and content for Posts 2 and 3. So I'll do that now. And now I can restart my server. Notice in our database viewer, we have all the new tables created, including two new comments with a PostId referencing a user, along with three new Posts. When we visit our newly created route at singlepost, you can see that we get back a single Post along with the two comments containing only the attributes we've assigned. But, remember, we also have a belongsTo association made of Post to User. Here we can see that we get back the associated userId, but we didn't get back any of the models data. To make sure that we get both associated models data, I can simply add a comma to our include, add in and another object with the model of User, along with the alias. Now I'll go down and comment out force so our tables don't get dropped, and I'll also comment out the create methods we use in order to add in our initial data, kill and then restart the server, refresh my page. And here you can see that our Post response now contains both the User model and the Comments model associations.

Many-to-Many Association
The last type of association we need to discuss is the many-to-many association. When creating this type of association, we need to define a relationship between two models using the belongsToMany method. We also need to make sure to define this association on both models. It is a common practice here to include an alias, although it's not required. It is, however, required to include a through property with value of what a new join table will be called. The join table in this example will be called UserProject. What this will do is create a brand-new table called UserProject that contains a foreign key to reference both the project and the user. So two new columns will be created called UserId and ProjectId, and this is what it will look like. Notice here that the name of the table does not get automatically pluralized and, instead, matches exactly what our through name is. Retrieving a user or project is very similar to previous examples. We just need to call one of our query methods like findById to retrieve the user, and then include the Project model along with the alias. And just like in previous examples, we can ask for only certain attributes in the response. Here is an example of what the response will look like based on the previous slide. Our user with an ID of 1 gets queried and includes an array of two projects that have already been associated with this user. It also includes the alias we've given of tasks. When creating a many-to-many or a one-to-many association, we are also provided by Sequelize getter and setter methods. These methods allow us to perform essentially CRUD operations on individual members of an association. There are a total of seven Get and Set methods. But let's look at the four most commonly used. These are set, add, get, and remove. Set is used when initially creating an association, and it accepts an array of IDs. When using any of these methods, the syntax is camelCasing with first the name of the getter or setter, followed by the name of the model or alias. Add is used to add a single member to an association. Get can be used to find all associated members. And remove can be used to remove a single associated member. And here is the example syntax. So after creating a new project, we then want to add a few new workers to this project. We can do this by chaining on the setWorkers method onto the response, passing in an array of IDs that we want to add. So, remember, we're using workers as an alias for our user. Now inside our database, what you'll see is something like this. Inside the UserProject table, we'll have two new rows added associating two users with a project. Now after a project is created, we may want to add a new worker to that project. To do this, we can use the addWorkers method. So here we're using a put request. Then inside the function, we first find a project by its ID, and then we take that found project and chain on the addWorkers method, passing in the ID of the worker we want to add. Okay, so now that you understand this concept, let's jump in the code and try it out.

Many-to-Many Example
Back in our editor, the first thing I'll do is create a new model called Project. We'll give Project a single attribute of title with a type of STRING. Next, I'll scroll down to create our new belongsToMany association of User belonging to many Project and Project belonging to many User. I'll make the through table named UserProjects and add aliases to both associations--Tasks for User and Workers for Project. I'll also add in a comment here as a reminder that a UserProject table gets created with the IDs of ProjectId and UserId. Now I'll create two new projects after syncing my tables. The first project will have a title of project 1, and then I will setWorkers 4 and 5 to be included with this project on creation. I'll also add in another project here with the title of project 2 without setting any workers. I can run my app now and expect to see two new tables created along with the new database entries. Now I'm going to open up my database viewer, and here you can see that a Projects and UserProjects tables were created. If we take a look inside UserProjects, we see the first project created has an ID of 1 with two associated users. Okay, great! Now let's go back in and test out adding a single worker to project 2. Before I forget, I'll comment out the code used to create these new projects, then I'll scroll up and add in a new route called addWorker. So I'll copy and paste one of my routes from above. We'll make this a put route with the route of addWorker. Inside the function, I'll call findById on the Project model passing in the ID of 2. Then I'll take the response and chain on the addWorkers method adding the user with an ID of 5. We won't be getting a response object to work with. So, instead, I'll just send back a text response of User added. So now I can kill and restart my server. And since we're using a put method, I have to use Postman. The route is localhost:8001/addworker. And here we get back our success message of User added. And then if we take a look at our database viewer, here you can see that a new user with an ID of 5 has been added to project 2. Let's do one more example for how to query our users and get back all their projects while filtering for attributes. This route will be called getUserProjects. Here I'm going to find all users in my database only retrieving the attribute of name, then include the model of Project along with the alias we've assigned of Tasks while only getting back the attribute of title. We'll display the results in JSON and catch any error. Now I'll again kill and restart my server, navigate in my browser to localhost:8001/getUserProjects. And here you can see a printout of all users with just their names, as well as any associated project titles.

Resumen
This module was all about associations. We explored the various types of associations that can be formed using Sequelize. This included forming a one-to-one association using belongsTo and hasOne, forming a one-to-many association using hasMany, and forming a many-to-many association using belongsToMany. We discussed how these associations create a new column with a foreign key containing the ID of the associated table. We then used our browser along with Postman to test routes and see what the response looks like in JSON. You now have a firm grasp on the fundamentals of using Sequelize inside a Node. Proyecto js. Now let's do something fun. In the next module, you will take what you've learned and build out a backend API using Sequelize and Express for an already developed Angular frontend.

Demo Application Using Angular
Introducción
Hello, and welcome back to the course. In this final module, we'll build a full stack application. We'll be using Angular on the frontend and Express along with Sequelize on the backend. The frontend code will already be provided to you so that we can work together on building out the API connecting Angular with a database. This means that you don't have to know a lick of Angular in order to follow along, although if you do want to know what's happening on the frontend, there are a number of amazing courses here on Pluralsight to get you familiar. You can find all the code to follow along here github. com/jakblak/Sequelize_BookStore. Here, I have provided you with the starter files located at the master branch along with the completed files located in the finished branch. Let's take a look at our demo app. First, when a user enters, we'll display a list of books retrieved from an SQLite database, along with a list of users. From here you'll be able to edit any of the users to add books to their reading list or to assign a favorite book. You can also find links to add a new book or to add a new user.

Configuración del proyecto
Before we get started, it's a good idea to install or upgrade the Angular CLI tool insider your terminal by typing the command npm i -g @angular/CLI. And now with the Angular CLI installed, let's now download the starter code. You can find the starter files for this project here at github. com/jakblak/Sequelize_BookStore. We can clone this repo by hitting this Clone button and then copying the GitHub link. Now inside of Visual Studio Code, I'm inside of this bookstore folder, and I can type the command to git clone pasting in the address of our GitHub repo, space dot, and this will make sure that a new folder doesn't get created. Now I can open up my Explorer, and we can see that we have a server and a source folder. And let's start off by opening up this package. json. Now in order to run our project, we can simply type npm start. And this is going to first start our Angular server and then start our Node server. Here we have the dependencies for Angular, and here we have the dependencies for Node. Inside of my server file, what I'm doing here is I'm just starting a simple Express server first loading up my Express middleware, then any APIs, and then starting the server. Inside of this API folder is where we're going to be declaring all of our routes. So if we look in this index. js file, we can see that we're just sending first off a get request, which is going to display the message hello world, and then we're going to load up our API user. route, which can be found in this user, and then user. route. So this user. route that we've defined right here, we'll load up the route at api/users, which, again, is right here. And then it's going to call the function controller. test, and this controller is found in the user. controller folder. And you can see the function called right here. Inside of this source folder is where we have our Angular files, and for the most part this already has a lot of code for you. So if we look inside this user folder inside of this user-edit folder, we have a user-edit. component. ts file. And this is where a lot of the logic will be for our application. Now as you can see, we are getting some red squigglies here. So let's fix that by including our npm modules. To do that, I'll open up my terminal, close this window, and from here, you can either type yarn, or you can type npm i. So I will just type yarn, and this is going to download and install all of the packages found in our package. json file for both the Angular frontend and our Node server. After downloading the Node modules, you may need to close and reopen your workspace in case you get any errors. And now you should see this node_modules folder. In order to run my project, I can type npm start. This is going to run both my Node server and our Angular server first running port 3000, and this is what you should see when you load up our application. We'll have Books with just one book here. We'll have Users, which will display two mock users. If I click on this Edit button, it's going to show us User and a couple of form fields, and then we also have links where we can add book and add user. And let's also look at what's happening on port 3000. So port 3000 is running our Node server, and here we get the message hello world, and then we can also navigate over to api/users, and we can see that we get our initial route user route works!

Database Setup
Now that we've explored our project, let's add in Sequelize and set up the database. To do this, we'll first need to add in a few modules. So inside my terminal, I'll type yarn add sequelize sqlite3. You can also use the command npm i instead of yarn if it's not already set up on your system. Now I'm going to create a new file that will serve as the entry point to our database. So this will be inside of the Models folder. So I'll right-click, and New File. And it will be called db. js. Inside of this file, I'm going to copy over and then edit some code from the Sequelize repo. So I'm over here at github. com/sequelize/express-example. Then inside this Models folder, we'll have this index. js file. This file will do two things for us. First, it's going to create our connection to the SQLite server. Second, it's going to load up and sync all of the models that we create. So I'll click Raw and then copy over the code, and I'll paste it inside of my db. js file. Scrolling up to the top here, the first edit that I'll make is to remove both environment and config. And then I'll also remove this if-else statement. This project is just for development, so I'm going to hardcode in my Sequelize connection. The connection code that I just pasted in is the same as you've used in previous modules, first connecting to our localhost, defining the dialect as SQLite, and setting up a storage file. Now in order to test this out, we need to have at least one model already created. So inside of my models, I'm going to right-click, New File, and let's name this file favorite. js. In our project, we will have a favorite model, and I'll paste this in as it's really simple. It's only going to have this one data type called title. The syntax here is a little different from previous examples. Instead of using Sequelize, we're using data types, and then we're going to be exporting this entire module. Now what will happen is this db. js file is going to iterate through all of the files contained inside of this models folder, and it will create all the models from the files that we've created. So when we sync the database, we should see one new model called Favorite created. So let's go ahead and do that now inside of our server. js file. Close out these other windows. So what I'm going to do here is just replace this app. listen, which runs are Express server, with db. sequelize. sync. So this is going to sync our database, and then it's going to run our server. This DB right here is a variable that's going to reference our db. js file that we just created. Now let's test this out by running our server, and you can do that by typing the command node server. js. So you can see here that we got our Favorites created. If I open up my Explorer, we now have a db. sqlite file. And let's open up our browser, and open up our newly created database inside of our Bookstore folder, click Browse Data, and here you can see that we get our new Favorites model created as a table inside of our database.

Create Models
Let's now finish up adding in our models. But before we do that, I'm going to kill my server and then add force set to true inside of sync, which is going to drop and re-create any tables. Close out my server, and then inside of my models folder, I'm going to create two new files. The first one is going to be user. js for our User model, and the second one is going to be book. js for our Book model. Inside of my user file, I'm first going to define a module. exports passing in Sequelize and data types. Then I'll define a function, and inside this function, I will declare a variable of User equaling sequelize. define naming my model User. We'll supply our User model with one attribute called name, and adding some simple validation, forcing the user to submit some data for this attribute. And here we can also define any associations. So for this model, I'm going to define two associations, the first one associated to Book and the second associated to Favorites. So we can say user. associate is equal to a function that accepts a parameter of models, and here we define the associations. So we need to use this models parameter, then specify the model. So the model is User. It's going to belong to many. So this is belongsToMany, passing in the model that we want to associate with. So we have to use this models parameter. Book, which we'll create here in a second. We'll be creating an alias, so this will be named Reading, and then we also need a through property, which will create a join table called ReadingList. For our other association, we can say models. User. hasOne, so User will have one Favorite. So we can say models. Favorite, and this association will put a foreign key of UserId inside of the Favorites table. And then we need to return our user, and that's it. And now for our Book model, I'm simply going to copy over this file that we've created, paste it into Book, and I'm going to hit Ctrl+H, which is Cmd+H if you're on a Mac, and I want to find all the references of User and replace it with Book. I'm going to simplify the attributes here, and we'll just have a title and author and a year attribute for our book. Book will have one single association, and then we just need to change the alias. So book will be associated to User, and instead of Reading, we'll have Readers. And I also need to change the association from Book to User. Okay, so that looks good. Let's now start up our server and see our newly created tables. Inside of my terminal, I'll just type node server. js. And now I'll open up my database. And you can see we have a Books table, a Users table, and a ReadingList join table. And also notice inside of this Favorites table, we have an association to our User as UserId.

Seed Database
And now let's go ahead and seed our database with some data. You've already been provided with two JSON files to perform the seeding. They can be found here inside of the models/seed folder. Let's open up the books. json archivo. Here you can find an array of objects that contain a title, author, and year to match what's found in our book model. We also have a users. json file with just a name property that matches what's found in our User model. Now let's create a seed file inside of this seed folder, which will be called seed-db. js. We start off by requiring in our models, which is located in the db. js file. And, next, we import our two JSON files containing our data. In order to use this in another file, I will define a module. exports, which will contain an object with one function called insert. The insert function will take the models we've imported and first use the User model to bulkCreate \_USERS data from the users. json archivo. And then we will do the same thing for our Book model. So we'll take the models folder, chain on Book, then bulkCreate our \_BOOKS. And then on creation, we will get the response, and we'll just send back a message of Success adding users and books. And I do need to fix these curlies just like that. And then, of course, we'll also catch any errors, and we'll just log them out. And now all we need to do is add the seed file into our server. js file. So at the top here, I will require in our seed file, and then at the bottom here, I can chain on another then promise in which I can call seed. insert. And this should do the work of seeding our database. Now I'll open up my terminal and type node server. js. We get our message, Success adding users and books. Now I'll reopen my SQLite database, and here we get our data for our books along with the data for our users.

Show All Books
With our database seeded and table set up, I can now remove this seed method, and I'll comment out force. I want to display all books when a user first enters our site. So let's now create an API route to perform this action that our frontend can connect to. So, first, I'm going to define an API location for books. So inside of my server/api folder, we have an index. js file. So let's open that up. And, first off, let's remove this initial get request. So below my users API, I'm going to create a route specifically for books, which is going to be located at api/books. We're going to reference a file called book. routes, which is located in a book folder. And now let's create both that folder and file, which is going to be located inside of this api folder. So I'll right click API, click New Folder. This will be called book. Then inside of book, we'll create two new files. The first file will be called book. routes. js, and the second file will be called book. controlador. js. Let's first look at this book. routes file. We'll start off by requiring in the modules that we'll need. First, the controller, then Express, and then our router. And at the bottom, we'll declare a module. exports to export all the routes that have been created. I'll create just one route in this file, which will be a get route located at allBooks, and we'll use a method that we'll create here called allBooks inside of the controller file. Now let's create this allBooks method. So inside of our controller file, we'll start off by requiring in the db. js file referring to it as models. And then we'll add in a single method called allBooks, which will look inside of the Book model to grab all the books and then send them back to the client in JSON. And now we just need to edit a couple lines of code in our frontend to make this work. So close out these files, and let's open up our src folder, under book. This will be in the books folder under the books. component and books. html. So here is our HTML, and this is hardcoded. So what I'll do is comment that out and then uncomment the code down here, which is going to iterate over the book and books, which we've already defined in our component. So inside of this component, all I need to do is uncomment the method that calls on the allBooks bookService. And let's just quickly look at this bookService which calls getBooks. And right here is where we're accessing our api/books route, and then we call this getBooks method, which calls on the allBooks route that we created. So now let's start up our server using npm start. I'm just going to load up both are Node server, as well as our Angular server. And here you can see that our books are now being displayed from our database.

Single User Route
Let's now create a new route to get and display all users right here. We'll also be changing this edit link so that it goes to a specific user. Back in my terminal, I'll first kill my server. And then I'm going to open up our user. routes file along with our user. controller file. And let's remove this exports. test method. And I'll also remove this initial get route. So here I'm going to start off by creating a new route for all users, which will use a method called allUsers in our controller file. No inside of our user. controller file, I'll paste in first a reference for our models and then the method that we'll be using to get allUsers. This method will look inside of the Users model and send back all users in JSON form. And now let's edit the Angular code in order to display all of our users. So I'll close these two files, and then we'll look inside of our src folder. And this will be inside of users. We'll open up our component and our HTML file. So this file does the work of displaying all users, and I will comment out what we already have. And then at the bottom here, I will uncomment the row that will iterate over all of our users and display them. Notice you that we have a router link that's going to route to an individual user passing in that user's ID. So I do need to edit this user--routing. module, which can be found inside of the users folder. In here I have the path, which is currently at edit--user, and I'm going to change this to :id. So this colon acts kind of like a variable reference for whatever gets passed into the URL. So now when the user clicks on edit-user link, it's going to take them to the UserEditComponent. So let's open up that UserEditComponent here, and we'll also open up the HTML file. Now for this HTML file, I'm going to go ahead and just remove everything here at the top. And then I'm going to scroll down to the bottom, and I'm going to uncomment everything up to the second to last line. So now let's look inside of our UserEditComponent. So at the top here, I'm going to get rid of this foods for loop, which was just displaying some mock data. And then I'm going to scroll down into this ngOnInit and uncomment these lines. And, first, we're going to get the ID from the parameter within the URL, and we'll be to pass it into this method called getUser. This getUser method that we've defined will call on our userService in the form of a getUserDetails method passing in the ID that we get again from the URL. So let's look at this getUserDetails method, which can be found in our userService. So here is our userService, and here is the getUserDetails method. So let's now create this corresponding route in our server. I'll close out our open files and scroll up into server, then let's open up our user. routes and our user. controlador. So inside of our user. routes, I'll add in a new get route. This route location will be at :/id. And notice how this matches our frontend route with the colon making our ID a variable. Then we're defining a new method called singleUser. So let's go ahead and create this singleUser method inside of our controller. So I'm just going to paste this in. And what this does is it grabs the ID from the URL using req. params. id. So now we have the ID of the user, and then we're going to pass that in to user. findById in order to grab that user, and then send it back in the form of JSON. And just one more thing that we need to do here is inside of our users folder, inside of our users. component, I need to make sure that we are grabbing all users so that it gets displayed inside of our HTML. And now I can go ahead and start my server saying npm start. Okay, so here we have all books. If I click on users, now we get displayed all of our users. And let's click on this Edit button, and here we get redirected to our single user. You can see that the name correctly displays as Ashton, and he's our first user in our database.

Save User Book
In our application, we're currently displaying a user's page. Here we have a drop-down option for submitting a book to this user's reading list. So when a user submits a particular book, I want that book to then be displayed below in their reading list. In order to do this, we're going to be associating a specific user with a specific book, and this will be done inside of our ReadingList table that we've already created. Back in our editor, let's now open up the user-edit. component, and we'll also open up the user-edit. html file. So inside this component, we already have the user ID and the book ID. We also already have the saveBook method, which performs the action of linking a user with a book. Right here we're defining a variable of ID, which is an object that contains the book ID and the user ID. We then pass in the ID that we've defined into our bookService via the method saveUserBook. This saveUserBook method performs a post request to the books API passing in the object that we've defined containing our user ID and book ID. Let's now create this saveUserBook route inside of our book routes. I'm now going to close out the bookService and the HTML file. And now I'm going to open up inside of our book routes the book. routes and the book. controlador. Instead of my book. routes. js file, I'm going to add in here a new post route of saveUserBook, which is going to reference our controller with a method called saveUserBook. Now let's go into the controller, and I'll scroll down and create a new method called saveUserBook. So for this method, first, I create a couple of variable references for what's going to be passed in for our book ID and for our user ID. Next, I call on our book model to find a specific book and then take that book and add into it a reader passing in the user's ID. On success, I respond with a success message, and also catch any errors. And now we can run our server by opening up the terminal and typing npm start. Then back in our application, I'll click on Users, click on our first user, and I will add a book to our user clicking Submit. I'm going to open up our terminal, and here we can see that we do get our success message, Success, book added for User! And let's also open up our database viewer. So if we click over to our reading list, here we can see that we have our UserId 1, which is Ashton, with the BookId of 2, which is the book that we just submitted.

Display User Books
Now at this point, we're able to grab a single user and submit a book to their reading list. However, it's not showing up right here. So let's go ahead and fix that. So what we need to do is open up our user. controller, and right here we're grabbing the user and sending the user back. So what we want to do is with our user include all the books that they have submitted to reading. So since we're using a join table, we can add a comma right here. And here is where we can include our model. So what we need to do is include a reference to our book model. So we'll say model is models. Book, and then, remember, we're using an alias for our many-to-many relationship of Reading. And that's all that we need to do. However, I'll also go ahead and specify a couple of attributes that I want to get back. So with our user, only send back the attributes of title and author. So now when we make a request for this user, we'll also get back their list of books under the property name of Reading. My server's already running here, so let's check out our app. We'll go ahead and refresh my application, and here we get displayed the Moby Dick book that we've already added. Now let's add in one more. We'll add in Life of Pi and submit that. And, boom, you can see it appear right away. Let's also take a look at our console. And in order to better see this object that we get, let's just copy this over into a JSON viewer. So over here at this website, I'm just going to copy this in, click Format, and here we can see under Reading we get an array of the two books that have been added to this user's reading list.

Save User Favorite
In the last clip, we displayed all of a user's books in a reading list. One thing that's cool about this many-to-many relationship is that once we've associated a book with a user, we don't have to worry about submitting the same item over and over again. It will only get displayed the single time. Hence, our database will only have a single reference. Below this Add to Reading option, we also have a Favorite Book option. So for this feature, we have a user with a hasOne association to a Favorite model. So let's code up that functionality now. And now back in our editor, I'm going to open up our user-edit. component along with our user. service. So here in our user-edit. component, we have a method called saveFavorites. This will pass along both the book title along with our user ID to the service that's called saveUserFavorite. Here is the saveUserFavorite method. This will in turn access an API endpoint called saveUserFav passing along the book title and user ID. So let's now create this saveUserFav endpoint inside of our user. routes file. So we'll open up our user. routes and are user. controlador. So inside of user. routes, I'll create a put route located at saveUserFav that will use a controller method also called saveUserFav. Now inside of her user. controller, I'll add in our saveUserFav method. First, I'll set variable references both for title and for user ID passing this data into my Favorite model using the create method. Here I'm able to use an ES6 syntax shortener for when an object key matches its value. So if we take a look at the Favorites table, notice here that the column names match what we're passing into our object of title and UserId. And then I'll respond with a success message, along with catching any errors. So since my server is still running, let's take a look at our app and see if this works. So I'll open up my console, and we will submit a new book. Hit Submit, and here you can see that we do get a success message with the Life of Pi book added for our user. But notice how it doesn't actually get shown in our browser window. And the reason is because we haven't included it into our model when we're retrieving our user. So now all we have to do is include this Favorite model up above right here. So what I can do is just include a reference to our Favorite model as a second object to our include. And that's it. So with our server still running, I should be able to just refresh the page, and here you can see that our favorite Life of Pi book has been added.

Add New User
In the last clip, we created the logic to add a favorite book for a specific user. One thing to note here is that unlike the many-to-many relationship, we can keep on submitting the same book over and over, and it actually does get saved to our database. So to show you what I mean, let's open up the console window, and I'm going to copy over this object that we're getting back. And let's take a look at what it looks like inside of this JSON viewer. And I'll hit Format. So this favorite is sending back the ID of 4. So let's see what that looks like inside of our database. So inside of our database viewer, let's open up this Favorites table, and here you can see that we've saved Life of Pi three times. And it's only responding with the most recent saved book. Now if this were a real application, I would perform the logic on the frontend first checking to see if a user has already saved a book under their ID, and if they have, then I would perform a put request and replace that book with whatever new book the user wants to save. So now back in our application, there's just one more thing that I want to do for this project, and that's going to be to add a user. So back in our code, let's open up our user. routes and our user. controlador. So I'll start off by adding in this new route, which will be a post route for add a user, and we'll create a new method called saveUser. So inside of our user. controller, I'll scroll all the way down and enter in our saveUser method. This will simply save name as a variable for request. cuerpo. name and submit that as an object to our create method on our User model. And then it will send back a response of JSON with our user. So now let's look at our frontend files inside of this add-user folder. We'll take a look at our user. component. So inside of our user. component, we have a saveUser method for which we're passing in a formValues parameter. And this is just going to be the username that the user submits. So we'll send that off to our userService, and then we'll redirect the user back to our main page, localhost/books. So with my server running, let's go ahead and test this out. We'll go ahead and refresh the application. And I'll add in a new name here of Tony. Click Submit. Click on our Users menu, and scroll down. And here you can see that our new user called Tony has been created. I'm going to leave this last bit of logic up to you, so go ahead and see if you can't add in the method to adding a new book, as well as any other functionality that you might like to add.

Conclusión
I'd like to thank you for taking the time to go through this course here on Pluralsight. I hope you feel like the investment was worthwhile and you now have more motivation to build your own projects using the technologies that we've covered. Now when looking at deployment options for stack, DigitalOcean has a very affordable plan that includes Postgres support. Another good option is for Heroku. Heroku offers support for Node. js apps along with Postgres. And Amazon offers a variety of products including AWS and RDS for Postgres. And I'd like to thank you once again for taking part in this course. Please feel free to leave a comment or question in the discussion area below. And I'll see you in the next one.
